class ApiEntreprise::PfEtablissementAdapter < ApiEntreprise::Adapter
  private

  def get_resource
    no_tahiti = @siret[0..5]
    ApiEntreprise::PF_API.entreprise(no_tahiti)
  end

  def process_params
    etablissement = data_source.sort_by { |a| a[:numEtablissement] }.detect { |h| h[:dateRadiation].nil? }
    if etablissement.present?
      etablissement = translate(etablissement)
      etablissement[:numero_voie]&.gsub!(/(\d+).*/, '\1')
      etablissement[:nom_voie]&.gsub!(/^[\d\s]+/, '')

      if etablissement[:entreprise_code_effectif_entreprise].present?
      end
      etablissement
    else
      {}
    end
  end

  def translation_map
    {
      :siret => 'entreprise.numeroTahiti',
      :entreprise_nom_commercial => 'nomCommercial',
      :numero_voie => 'numero_voie', # generated by normalize_street
      :nom_voie => 'nom_voie', # generated by normalize_street
      :code_postal => 'entreprise.code_postal', # generated by normalize_city
      :localite => 'entreprise.commune', # generated by normalize_city
      :adresse => 'pointKilometrique(PK)+numero_voie()+nom_voie()+immeuble+quartier+adresseGeo()+communeGeo.communeAssociee()',
      :entreprise_raison_sociale => 'entreprise.raisonSociale',
      :entreprise_forme_juridique => 'entreprise.formeJuridique.libelle',
      :entreprise_forme_juridique_code => 'entreprise.formeJuridique.code',
      :entreprise_code_effectif_entreprise => 'entreprise.classeEffectif.id',
      :entreprise_date_creation => 'dateInscription',
      :libelle_naf => 'activitePrincipale.libelle',
      :naf => 'activitePrincipale.code'
    }
  end

  # noinspection RubyLiteralArrayInspection
  NOM_VOIES = [
    'avenue', 'av', 'angle', 'rue', 'boulevard', 'chemin', 'ave', 'bvd', 'cours', 'place', 'allée', 'route', 'immeuble',
    'lot', 'passage', 'servitude', 'blvd', 'pointe', 'pont', 'av.', 'bd', 'blv', 'ecole', 'école'
  ]
  NOM_VOIES_RE = NOM_VOIES.join('|')

  def translate(json)
    normalize_street(json)
    normalize_city(json)

    etablissement = {}
    translation_map.each do |fr, pf|
      concatenation = pf.include? '+'
      pf.split('+').each do |expression|
        value = json
        variable = expression
        label = expression
        expression.split('.').each do |key|
          # 'variable(label)' or 'variable'
          /(?<variable>[^(]+)(?:\((?<label>[^)]*)\))?/ =~ key
          value = value[variable.to_sym] if value
        end
        if value
          add_value(etablissement, fr, get_value(value, concatenation, label, variable))
        end
      end
    end
    etablissement
  end

  def add_value(hash, key, value)
    if hash[key].present?
      hash[key] += "\r\n" + value
    else
      hash[key] = value.dup
    end
  end

  def get_value(value, concatenation, label, default_label)
    if concatenation
      label ||= default_label.gsub(/\p{Lu}+/) { |w| ' ' + w.downcase }
      if label.present?
        value = label + ' ' + value.to_s
      end
    end
    value
  end

  # generate :numero_voie & :nom_voie entries from :rue value
  def normalize_street(json)
    if (rue = json[:rue]).present?
      json[:numero_voie] = rue[/^\s*(\d+)/, 1]
      voie = rue[/^[ \d]*(.*)/, 1]
      if !/^(#{NOM_VOIES_RE})/i.match?(voie)
        voie = 'rue ' + voie
      end
      json[:nom_voie] = voie
    end
  end

  # generate :code_postal & :commune entries from :adressePostale
  def normalize_city(json)
    entreprise = json[:entreprise]
    if entreprise && (ap = entreprise[:adressePostale]).present?
      entreprise[:code_postal] = ap[/^\s*(\d+)/, 1]
      entreprise[:commune] = ap[/^[ \d]*(.*)/, 1]
    end
  end
end
